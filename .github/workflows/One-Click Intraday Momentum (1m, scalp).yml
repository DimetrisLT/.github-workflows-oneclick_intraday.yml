import numpy as np, pandas as pd

def rsi(series, n=14):
    d = series.diff()
    up = np.where(d > 0, d, 0.0)
    dn = np.where(d < 0, -d, 0.0)
    up = pd.Series(up, index=series.index).ewm(alpha=1/n, adjust=False).mean()
    dn = pd.Series(dn, index=series.index).ewm(alpha=1/n, adjust=False).mean()
    rs = up / dn.replace(0, np.nan)
    return 100 - (100/(1+rs))

def macd(series, fast=12, slow=26, signal=9):
    ema_f = series.ewm(span=fast, adjust=False).mean()
    ema_s = series.ewm(span=slow, adjust=False).mean()
    m = ema_f - ema_s
    s = m.ewm(span=signal, adjust=False).mean()
    return m, s, m - s

def vwap(df):
    tp = (df["high"] + df["low"] + df["close"]) / 3.0
    return (tp * df["volume"]).cumsum() / df["volume"].cumsum().replace(0, np.nan)

def obv(df):
    r = df["close"].pct_change().fillna(0.0)
    return (np.sign(r) * df["volume"]).cumsum()

def feature_table(df: pd.DataFrame) -> pd.DataFrame:
    X = df.copy()

    # užtikrinam, kad baziniai stulpeliai yra Series(float)
    for c in ["open","high","low","close","volume"]:
        if c in X.columns:
            X[c] = pd.to_numeric(X[c], errors="coerce")

    close  = X["close"]
    volume = X["volume"]

    X["ret1"]    = close.pct_change().fillna(0.0)
    X["rvol20"]  = volume / volume.rolling(20).mean()
    X["hl_range"]= (X["high"] - X["low"]) / close.shift()

    # VWAP / OBV
    X["vwap"] = vwap(X)
    X["obv"]  = obv(X)

    # EMA ir santykis – viskas iš Series, kad nebūtų daugiastulpelių
    ema5  = close.ewm(span=5, adjust=False).mean()
    ema20 = close.ewm(span=20, adjust=False).mean()
    X["ema5"]  = ema5
    X["ema20"] = ema20
    X["ema_ratio"] = (close - ema5) / ema20

    # RSI / MACD
    X["rsi14"] = rsi(close, 14)
    m, s, h = macd(close, 12, 26, 9)
    X["macd"] = m; X["macd_sig"] = s; X["macd_hist"] = h

    # Trumpalaikė volatilumas
    X["vola20"] = X["ret1"].rolling(20).std()

    return X
