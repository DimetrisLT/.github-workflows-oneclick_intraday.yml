import numpy as np
import pandas as pd

def rsi(series, n=14):
    d = series.diff()
    up = np.where(d > 0, d, 0.0)
    dn = np.where(d < 0, -d, 0.0)
    up = pd.Series(up, index=series.index).ewm(alpha=1/n, adjust=False).mean()
    dn = pd.Series(dn, index=series.index).ewm(alpha=1/n, adjust=False).mean()
    rs = up / dn.replace(0, np.nan)
    return 100 - (100/(1+rs))

def macd(series, fast=12, slow=26, signal=9):
    ema_f = series.ewm(span=fast, adjust=False).mean()
    ema_s = series.ewm(span=slow, adjust=False).mean()
    m = ema_f - ema_s
    s = m.ewm(span=signal, adjust=False).mean()
    return m, s, m - s

def vwap(df):
    tp = (df["high"] + df["low"] + df["close"]) / 3.0
    return (tp * df["volume"]).cumsum() / df["volume"].cumsum().replace(0, np.nan)

def obv(df):
    r = df["close"].pct_change().fillna(0.0)
    return (np.sign(r) * df["volume"]).cumsum()

def _ensure_close_column(df: pd.DataFrame) -> pd.DataFrame:
    """
    Garantuoja, kad df turės skaitinį stulpelį 'close'.
    Ieško alternatyvų: 'adj close', bet ir bet kurio stulpelio su 'close' pavadinime.
    """
    cols = [str(c).lower() for c in df.columns]
    df.columns = cols
    if "close" not in df.columns:
        # populiariausia alternatyva
        if "adj close" in df.columns:
            df["close"] = pd.to_numeric(df["adj close"], errors="coerce")
        else:
            cand = next((c for c in df.columns if "close" in c), None)
            if cand is not None:
                df["close"] = pd.to_numeric(df[cand], errors="coerce")
    if "close" not in df.columns:
        # jei vis tiek nėra – negalim skaičiuoti indikatorių
        return pd.DataFrame(columns=["close"])
    return df

def feature_table(df: pd.DataFrame) -> pd.DataFrame:
    X = df.copy()
    X = _ensure_close_column(X)
    if "close" not in X.columns or X.empty:
        return pd.DataFrame()

    # priverstinai skaitiniai baziniai laukai (jei yra)
    for c in ["open", "high", "low", "close", "volume"]:
        if c in X.columns:
            X[c] = pd.to_numeric(X[c], errors="coerce")

    close  = X["close"]
    volume = X["volume"] if "volume" in X.columns else pd.Series(index=X.index, dtype=float)

    X["ret1"]     = close.pct_change().fillna(0.0)
    if "volume" in X.columns:
        X["rvol20"]   = volume / volume.rolling(20).mean()
    else:
        X["rvol20"]   = np.nan
    if {"high","low"}.issubset(X.columns):
        X["hl_range"] = (X["high"] - X["low"]) / close.shift()
    else:
        X["hl_range"] = np.nan

    # VWAP/OBV apskaičiuojam tik jei turim reikalingus stulpelius
    if {"high","low","close","volume"}.issubset(X.columns):
        X["vwap"] = vwap(X)
    else:
        X["vwap"] = np.nan
    if {"close","volume"}.issubset(X.columns):
        X["obv"]  = obv(X)
    else:
        X["obv"] = np.nan

    ema5  = close.ewm(span=5,  adjust=False).mean()
    ema20 = close.ewm(span=20, adjust=False).mean()
    X["ema5"]      = ema5
    X["ema20"]     = ema20
    X["ema_ratio"] = (close - ema5) / ema20

    X["rsi14"] = rsi(close, 14)
    m, s, h    = macd(close, 12, 26, 9)
    X["macd"] = m; X["macd_sig"] = s; X["macd_hist"] = h

    X["vola20"] = X["ret1"].rolling(20).std()
    return X
